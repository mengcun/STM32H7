/**
  ******************************************************************************
  * @file    STM32H7_CoreBoard/Middlewares/Third_Party/FatFs/ff13b/extend_functions/FasFt_User_Bsp.c
  * @author  CME
  * @version SW:V1.0.0 HW:V1.0
  * @date    28-September-2018
  * @brief   This file provides set of firmware functions to manage:
  *					 -
  *
  @verbatim
 ===============================================================================
                        ##### How to use this file #####
 ===============================================================================
  [..]
	The FasFt_User canbe used as follows:
	(#)...
		(++)...
				(+++)...
  @endverbatim
  */

/* Includes ---------------------------------------------------------------------------------------*/
/***************************************Include StdLib**********************************************/
#include "stdint.h"
/*******************************************APP/BSP*************************************************/
#include "Coreboard_Bsp.h"
/********************************************Macro**************************************************/
/**********************************************OS***************************************************/
/********************************************STwin**************************************************/
/********************************************FatFS**************************************************/

/** @addtogroup STM32H743II_CoreBoard
  * @{
  */
/** @defgroup 	FasFt_User FasFt_User
  * @brief 		FasFt_User
  * @note		FasFt_User
  * @{
  */

/* Exported Variable------------------------------------------------------------------------------*/
/** @defgroup FasFt_User_Exported Variable FasFt_User Exported Variable
  * @{
  */
/**
  * @brief  The define of the variable
  */
BYTE Buff[4096] __attribute__ ((aligned (4))) ;	/* Working buffer */  

char ReadDataBuff[BUF_SIZE];
char WriteDataBuff[BUF_SIZE] = {"This is the test for the write file."};

/**
  * @brief  The types of files that FasFt support
  */
uint8_t*const FILE_TYPE_TBL[FILE_MAX_TYPE_NUM][FILE_MAX_SUBT_NUM]=
{
{"BIN"},						//BIN文件
{"LRC"},						//LRC文件
{"NES","SMS"},					//NES/SMS文件
{"TXT","C","H"},				//文本文件
{"WAV","MP3","APE","FLAC"},		//支持的音乐文件
{"BMP","JPG","JPEG","GIF"},		//图片文件
{"AVI"},						//视频文件
};

/**
  * @brief  Public file
  */
FATFS *fs[FF_VOLUMES];			//逻辑磁盘工作区.	 
FIL *file;	  					//文件1
FIL *ftemp;	  					//文件2.
UINT br,bw;						//读写变量
FILINFO fileinfo;				//文件信息
DIR dir;  						//目录

uint8_t *fatbuf;				//SD卡数据缓存区

/** @}
*/
/*--------------------------------------FasFt_User Exported Variable---------------------------------*/

/* Exported types ---------------------------------------------------------------------------------*/

/* Exported functions -----------------------------------------------------------------------------*/
/** @defgroup FasFt_User_Exported_Functions FasFt_User Exported Functions
  * @{
  */
/** @defgroup FasFt_User_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
===============================================================================
            ##### Initialization and Configuration functions #####
===============================================================================
  [..]
	    This subsection provides a set of functions allowing to initialize FasFt_User
  @endverbatim
  * @{
  */
/**
  * @brief Initialize the FasFt_User according to the specified, mainly Memory allocation
  * @retval 0: success, 1: failure
  */
uint8_t Bsp_FatFs_Init(void)
{
	uint8_t i;
	for(i=0;i<FF_VOLUMES;i++)
	{
		fs[i]=(FATFS*)Bsp_mymalloc(SRAMIN,sizeof(FATFS));	//为磁盘i工作区申请内存	
		if(!fs[i])
		{
			break;
		}
	}
	file=(FIL*)Bsp_mymalloc(SRAMIN,sizeof(FIL));			//为file申请内存
	ftemp=(FIL*)Bsp_mymalloc(SRAMIN,sizeof(FIL));			//为ftemp申请内存
	fatbuf=(uint8_t*)Bsp_mymalloc(SRAMIN,512);				//为fatbuf申请内存
	if(i==FF_VOLUMES&&file&&ftemp&&fatbuf)
	{
		return 0;  											//申请有一个失败,即失败.
	}
	else 
	{
		return 1;
	}		
}
/** @}
*/
/*********************FasFt_User Exported Functions Group1**************************/

/** @defgroup FasFt_User_Exported_Functions_Group2 Operation Functions
  *  @brief   Operation Functions
  *
@verbatim
===============================================================================
            ##### 					Operation Functions 						#####
===============================================================================
  [..]
			This subsection provides a set of functions allowing to manage the FasFt_User
  @endverbatim
  * @{
  */
/**
  * @brief Tell the type of file
  * @param fname: The name of file.
  * @retval 0XFF,Can not tell the file type(The High 4 bit is the main type, the Low 4 bit is the sub_main type. )
  */
uint8_t Bsp_FatFs_File_Tell(uint8_t *fname)
{
	uint8_t tbuf[5];
	uint8_t *attr='\0';		//后缀名
	uint8_t i=0,j;
	while(i<250)
	{
		i++;
		if(*fname=='\0')
		{
			break;			//偏移到了最后了.
		}
		fname++;
	}
	if(i==250)
	{
		return 0XFF;		//错误的字符串.
	}
 	for(i=0;i<5;i++)		//得到后缀名
	{
		fname--;
		if(*fname=='.')
		{
			fname++;
			attr=fname;
			break;
		}
  	}
	strcpy((char *)tbuf,(const char*)attr);		//copy
 	for(i=0;i<4;i++)tbuf[i]=char_upper(tbuf[i]);//全部变为大写 
	for(i=0;i<FILE_MAX_TYPE_NUM;i++)			//大类对比
	{
		for(j=0;j<FILE_MAX_SUBT_NUM;j++)		//子类对比
		{
			if(*FILE_TYPE_TBL[i][j]==0)
			{
				break;							//此组已经没有可对比的成员了.
			}
			if(strcmp((const char *)FILE_TYPE_TBL[i][j],(const char *)tbuf)==0)//找到了
			{
				return (i<<4)|j;
			}
		}
	}
	return 0XFF;								//没找到		 			   
}	 

/**
  * @brief  Get the Volum of the disk. Total and Free
  * @param  drv:磁盘编号("0:"/"1:")
  * @param  total:总容量	 （单位KB）
  * @param  free:剩余容量	 （单位KB）
  * @retval  0,正常.其他,错误代码
*/

uint8_t Bsp_FatFs_GetDisk_Volume(uint8_t *drv,uint32_t *total,uint32_t *free)
{
	FATFS *fs1;
	uint8_t res;
    uint32_t fre_clust=0, fre_sect=0, tot_sect=0;
    //得到磁盘信息及空闲簇数量
    res =(uint32_t)f_getfree((const TCHAR*)drv, (DWORD*)&fre_clust, &fs1);
    if(res==0)
	{											   
	    tot_sect=(fs1->n_fatent-2)*fs1->csize;	//得到总扇区数
	    fre_sect=fre_clust*fs1->csize;			//得到空闲扇区数	   
#if FF_MAX_SS!=512				  				//扇区大小不是512字节,则转换为512字节
		tot_sect*=fs1->ssize/512;
		fre_sect*=fs1->ssize/512;
#endif	  
		*total=tot_sect>>1;	//单位为KB
		*free=fre_sect>>1;	//单位为KB 
 	}
	return res;
}	

/**
  * @brief File Copy,将psrc文件,copy到pdst. make sure the size is less 4GB
  * @param fcpymsg,函数指针,用于实现拷贝时的信息显示
  * @param pname:文件名
  * @param pct:百分比
  * @param mode:[0]:更新文件名; [1]:更新百分比pct; [2]:更新文件夹; [3~7]:保留
  * @param psrc,pdst:源文件和目标文件
  * @param totsize:总大小(当totsize为0的时候,表示仅仅为单个文件拷贝)
  * @param cpdsize:已复制了的大小.
  * @param fwmode:文件写入模式 0:不覆盖原有的文件;1:覆盖原有的文件
  * @retval 0:正常;0XFF:强制退出;其他:退出
  */
uint8_t Bsp_FatFs_CopyFile(uint8_t(*fcpymsg)(uint8_t*pname,uint8_t pct,uint8_t mode),uint8_t *psrc,uint8_t *pdst,uint32_t totsize,uint32_t cpdsize,uint8_t fwmode)
{
	uint8_t res;
    uint16_t br=0;
	uint16_t bw=0;
	FIL *fsrc=0;
	FIL *fdst=0;
	uint8_t *fbuf=0;
	uint8_t curpct=0;
	unsigned long long lcpdsize=cpdsize; 
 	fsrc=(FIL*)Bsp_mymalloc(SRAMIN,sizeof(FIL));//申请内存
 	fdst=(FIL*)Bsp_mymalloc(SRAMIN,sizeof(FIL));
	fbuf=(uint8_t*)Bsp_mymalloc(SRAMIN,8192);
  	if(fsrc==NULL||fdst==NULL||fbuf==NULL)
	{
		res=100;								//前面的值留给fatfs
	}
	else
	{   
		if(fwmode==0)
		{
			fwmode=FA_CREATE_NEW;				//不覆盖
		}
		else 
		{
			fwmode=FA_CREATE_ALWAYS;	  		//覆盖存在的文件
		}
	 	res=f_open(fsrc,(const TCHAR*)psrc,FA_READ|FA_OPEN_EXISTING);	//打开只读文件
	 	if(res==0)
		{
			res=f_open(fdst,(const TCHAR*)pdst,FA_WRITE|fwmode); 		//第一个打开成功,才开始打开第二个
		}
		if(res==0)//两个都打开成功了
		{
			if(totsize==0)//仅仅是单个文件复制
			{
				totsize=fsrc->obj.objsize;
				lcpdsize=0;
				curpct=0;
		 	}
			else 
			{
				curpct=(lcpdsize*100)/totsize;	//得到新百分比
			}
			fcpymsg(psrc,curpct,0X02);			//更新百分比
			while(res==0)//开始复制
			{
				res=f_read(fsrc,fbuf,8192,(UINT*)&br);	//源头读出512字节
				if(res||br==0)
				{
					break;
				}
				res=f_write(fdst,fbuf,(UINT)br,(UINT*)&bw);	//写入目的文件
				lcpdsize+=bw;
				if(curpct!=(lcpdsize*100)/totsize)//是否需要更新百分比
				{
					curpct=(lcpdsize*100)/totsize;
					if(fcpymsg(psrc,curpct,0X02))//更新百分比
					{
						res=0XFF;//强制退出
						break;
					}
				}			     
				if(res||bw<br)
				{
					break;       
				}
			}
		    f_close(fsrc);
		    f_close(fdst);
		}
	}
	Bsp_myfree(SRAMIN,fsrc);//释放内存
	Bsp_myfree(SRAMIN,fdst);
	Bsp_myfree(SRAMIN,fbuf);
	return res;
}

/**
  * @brief  得到路径下的文件夹
  * @param  dpfn:磁盘编号("0:"/"1:")
  * @retval  0,路径就是个卷标号;其他,文件夹名字首地址
*/
uint8_t* Bsp_FatFs_GetSrc_Dname(uint8_t* dpfn)
{
	uint16_t temp=0;
 	while(*dpfn!=0)
	{
		dpfn++;
		temp++;	
	}
	if(temp<4)return 0; 
	while((*dpfn!=0x5c)&&(*dpfn!=0x2f))dpfn--;	//追述到倒数第一个"\"或者"/"处 
	return ++dpfn;
}

/**
  * @brief  得到文件夹大小,注意文件夹大小不要超过4GB.
  * @param  fdname:文件夹名称
  * @retval  0,文件夹大小为0,或者读取过程中发生了错误; 其他,文件夹大小.
*/

uint32_t Bsp_FatFs_GetFile_Size(uint8_t *fdname)
 {
#define MAX_PATHNAME_DEPTH	512+1	//最大目标文件路径+文件名深度
	uint8_t res=0;	  
    DIR *fddir=0;					//目录
	FILINFO *finfo=0;				//文件信息
	uint8_t * pathname=0;			//目标文件夹路径+文件名
 	uint16_t pathlen=0;				//目标路径长度
	uint32_t fdsize=0;

	fddir=(DIR*)Bsp_mymalloc(SRAMIN,sizeof(DIR));//申请内存
 	finfo=(FILINFO*)Bsp_mymalloc(SRAMIN,sizeof(FILINFO));
   	if(fddir==NULL||finfo==NULL)res=100;
	if(res==0)
	{ 
 		pathname=Bsp_mymalloc(SRAMIN,MAX_PATHNAME_DEPTH);	    
 		if(pathname==NULL)res=101;	   
 		if(res==0)
		{
			pathname[0]=0;	    
			strcat((char*)pathname,(const char*)fdname); 	//复制路径	
		    res=f_opendir(fddir,(const TCHAR*)fdname); 		//打开源目录
		    if(res==0)										//打开目录成功 
			{														   
				while(res==0)								//开始复制文件夹里面的东东
				{
			        res=f_readdir(fddir,finfo);				//读取目录下的一个文件
			        if(res!=FR_OK||finfo->fname[0]==0)
					{
						break;								//错误了/到末尾了,退出
					}
			        if(finfo->fname[0]=='.')
					{
						continue;     						//忽略上级目录
					}
					if(finfo->fattrib&0X10)					//是子目录(文件属性,0X20,归档文件;0X10,子目录;)
					{
 						pathlen=strlen((const char*)pathname);				//得到当前路径的长度
						strcat((char*)pathname,(const char*)"/");			//加斜杠
						strcat((char*)pathname,(const char*)finfo->fname);	//源路径加上子目录名字
 						Bsp_Printf("\r\nsub folder:%s\r\n",pathname);		//打印子目录名
						fdsize+=Bsp_FatFs_GetFile_Size(pathname);			//得到子目录大小,递归调用
						pathname[pathlen]=0;								//加入结束符
					}
					else 
					{
						fdsize+=finfo->fsize;								//非目录,直接加上文件的大小
					}
				} 
		    }	  
  			Bsp_myfree(SRAMIN,pathname);	     
		}
 	}
	Bsp_myfree(SRAMIN,fddir);    
	Bsp_myfree(SRAMIN,finfo);
	if(res)return 0;
	else return fdsize;
}

/**
  * @brief 文件夹赋值,将psrc文件夹,copy到pdst文件夹. make sure the size is less 4GB，pdst:必须形如"X:"/"X:XX"/"X:XX/XX"之类的.而且要实现确认上一级文件夹存在
  * @param fcpymsg,函数指针,用于实现拷贝时的信息显示
  * @param pname:文件夹名
  * @param pct:百分比
  * @param mode:[0]:更新文件名; [1]:更新百分比pct; [2]:更新文件夹; [3~7]:保留
  * @param psrc,pdst:源文件夹和目标文件夹
  * @param totsize:总大小(当totsize为0的时候,表示仅仅为单个文件拷贝)
  * @param cpdsize:已复制了的大小.
  * @param fwmode:文件写入模式 0:不覆盖原有的文件;1:覆盖原有的文件
  * @retval 0:正常;0XFF:强制退出;其他:退出
  */

uint8_t Bsp_FatFs_CopyFolder(uint8_t(*fcpymsg)(uint8_t*pname,uint8_t pct,uint8_t mode),uint8_t *psrc,uint8_t *pdst,uint32_t *totsize,uint32_t *cpdsize,uint8_t fwmode)
{
#define MAX_PATHNAME_DEPTH	512+1	//最大目标文件路径+文件名深度
	uint8_t res=0;	  
    DIR *srcdir=0;		//源目录
	DIR *dstdir=0;		//源目录
	FILINFO *finfo=0;	//文件信息
	uint8_t *fn=0;   		//长文件名

	uint8_t * dstpathname=0;	//目标文件夹路径+文件名
	uint8_t * srcpathname=0;	//源文件夹路径+文件名
	
 	uint16_t dstpathlen=0;	//目标路径长度
 	uint16_t srcpathlen=0;	//源路径长度

  
	srcdir=(DIR*)Bsp_mymalloc(SRAMIN,sizeof(DIR));//申请内存
 	dstdir=(DIR*)Bsp_mymalloc(SRAMIN,sizeof(DIR));
	finfo=(FILINFO*)Bsp_mymalloc(SRAMIN,sizeof(FILINFO));

   	if(srcdir==NULL||dstdir==NULL||finfo==NULL)res=100;
	if(res==0)
	{ 
 		dstpathname=Bsp_mymalloc(SRAMIN,MAX_PATHNAME_DEPTH);
		srcpathname=Bsp_mymalloc(SRAMIN,MAX_PATHNAME_DEPTH);
 		if(dstpathname==NULL||srcpathname==NULL)res=101;	   
 		if(res==0)
		{
			dstpathname[0]=0;
			srcpathname[0]=0;
			strcat((char*)srcpathname,(const char*)psrc); 	//复制原始源文件路径	
			strcat((char*)dstpathname,(const char*)pdst); 	//复制原始目标文件路径	
		    res=f_opendir(srcdir,(const TCHAR*)psrc); 		//打开源目录
		    if(res==0)//打开目录成功 
			{
  				strcat((char*)dstpathname,(const char*)"/");//加入斜杠
 				fn=Bsp_FatFs_GetSrc_Dname(psrc);
				if(fn==0)//卷标拷贝
				{
					dstpathlen=strlen((const char*)dstpathname);
					dstpathname[dstpathlen]=psrc[0];	//记录卷标
					dstpathname[dstpathlen+1]=0;		//结束符 
				}
				else 
				{
					strcat((char*)dstpathname,(const char*)fn);//加文件名	
				}					
 				fcpymsg(fn,0,0X04);//更新文件夹名
				res=f_mkdir((const TCHAR*)dstpathname);//如果文件夹已经存在,就不创建.如果不存在就创建新的文件夹.
				if(res==FR_EXIST)
				{
					res=0;
				}
				while(res==0)//开始复制文件夹里面的东东
				{
			        res=f_readdir(srcdir,finfo);					//读取目录下的一个文件
			        if(res!=FR_OK||finfo->fname[0]==0)
					{
						break;		//错误了/到末尾了,退出
					}
			        if(finfo->fname[0]=='.')
					{
						continue;     			//忽略上级目录
					}
					fn=(uint8_t*)finfo->fname; 							//得到文件名
					dstpathlen=strlen((const char*)dstpathname);	//得到当前目标路径的长度
					srcpathlen=strlen((const char*)srcpathname);	//得到源路径长度

					strcat((char*)srcpathname,(const char*)"/");//源路径加斜杠
 					if(finfo->fattrib&0X10)//是子目录(文件属性,0X20,归档文件;0X10,子目录;)
					{
						strcat((char*)srcpathname,(const char*)fn);		//源路径加上子目录名字
						res=Bsp_FatFs_CopyFolder(fcpymsg,srcpathname,dstpathname,totsize,cpdsize,fwmode);	//拷贝文件夹
					}
					else //非目录
					{
						strcat((char*)dstpathname,(const char*)"/");//目标路径加斜杠
						strcat((char*)dstpathname,(const char*)fn);	//目标路径加文件名
						strcat((char*)srcpathname,(const char*)fn);	//源路径加文件名
 						fcpymsg(fn,0,0X01);//更新文件名
						res=Bsp_FatFs_CopyFile(fcpymsg,srcpathname,dstpathname,*totsize,*cpdsize,fwmode);//复制文件
						*cpdsize+=finfo->fsize;//增加一个文件大小
					}
					srcpathname[srcpathlen]=0;//加入结束符
					dstpathname[dstpathlen]=0;//加入结束符	    
				} 
		    }	  
  			Bsp_myfree(SRAMIN,dstpathname);
 			Bsp_myfree(SRAMIN,srcpathname); 
		}
 	}
	Bsp_myfree(SRAMIN,srcdir);
	Bsp_myfree(SRAMIN,dstdir);
	Bsp_myfree(SRAMIN,finfo);
    return res;	  
}

/**
  * @brief 显示目录下的文件
  * @param path,要显示的目录
  * @retval 0:正常;其他:退出
  */
uint8_t Bsp_FatFs_ViewDir(const TCHAR* path)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;
	DIR DirInf;
	FILINFO FileInf;
	uint32_t cnt = 0;

	result = f_opendir(&DirInf, path); 
	if (result != FR_OK)
	{
		Bsp_Printf("Open the directory %s failed (%d).\r\n", path, result);
		return 1;
	}
	Bsp_Printf("Attribute		|	size	|	Primary file name	|	Altenative file name\r\n");
	for (cnt = 0; ;cnt++)
	{
		result = f_readdir(&DirInf,&FileInf); 		/* 读取目录项，索引会自动下移 */
		if (result != FR_OK || FileInf.fname[0] == 0)
		{
			return 1;
		}
		if (FileInf.fname[0] == '.')
		{
			continue;
		}
		if (FileInf.fattrib & AM_DIR)
		{
			Bsp_Printf("(0x%02d)contents	|	%llud	|	%s	|	%s\r\n", FileInf.fattrib, FileInf.fsize, FileInf.fname, FileInf.altname);
			return 0;
		}
		else
		{
			Bsp_Printf("(0x%02d)files		|	%llud	|	%s	|	%s\r\n", FileInf.fattrib, FileInf.fsize, FileInf.fname, FileInf.altname);
			return 0;
		}
	}
}

/**
  * @brief 在SD卡创建一个新文件
  * @param path,要创建文件所在的目录
  * @param fname,要创建的文件，必须包含绝对路径
  * @retval 0:正常;其他:退出
  */
uint8_t Bsp_FatFs_CreateNewFile(const TCHAR* path, const TCHAR* fname)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;
	FIL file;
	DIR DirInf;
	uint32_t bw;
	
	result = f_opendir(&DirInf, path);
	if (result != FR_OK)
	{
		Bsp_Printf("Open the directory %s failed (%d).\r\n", path, result);
		return 1;
	}
	result = f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE);
	if (result !=  FR_OK)
	{
		Bsp_Printf("The File %s is opened failed (%d).\r\n",fname, result);
		return 1;
	}
	result = f_write(&file, "FatFS Write Test \r\n www.IEECHN.com \r\n", 34, &bw);
	f_close(&file);
	if (result == FR_OK)
	{
		Bsp_Printf("Creat file %s and write data success (%d).\r\n", fname, result);
		return 0;
	}
	else
	{
		Bsp_Printf("Creat file %s and write data failure (%d).\r\n", fname, result);
		return 0;
	}		
}

/**
  * @brief 在SD卡创建一个新目录
  * @param path,要创建文件所在的目录
  * @retval 0:正常;其他:退出
  */
uint8_t Bsp_FatFs_CreateDir(const TCHAR* path)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;

	result = f_mkdir(path);
	if (result == FR_OK)
	{
		Bsp_Printf("Creat Directoy %s Success (%d).\r\n", path, result);
		return 0;
	}
	else if (result == FR_EXIST)
	{
		Bsp_Printf("The directory %s already existt (%d).\r\n", path, result);
		return 2;
	}
	else
	{
		Bsp_Printf("Creat Directoy %s Fail (%d).\r\n", path, result);
		return 1;
	}
}

/**
  * @brief 在SD卡删除一个文件或文件夹
  * @param path,要创建的文件或文件夹所在目录
  * @param fname,要删除的文件或文件夹，必须是带绝对路径
  * @retval 0:正常;其他:退出
  */

uint8_t Bsp_FatFs_DeleteDirFile(const TCHAR* path, const TCHAR* fname)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;
	DIR DirInf;

	result = f_opendir(&DirInf, path);
	if (result != FR_OK)
	{
		Bsp_Printf("Open the directory %s failed (%d).\r\n", path, result);
		return 1;
	}
	result = f_unlink(fname);
	if (result == FR_OK)
	{
		Bsp_Printf("Delte The Directory %s success (%d).\r\n", fname, result);
		return 0;
	}
	else if (result == FR_NO_FILE)
	{
		Bsp_Printf("The Directory %s don't exist (%d). \r\n", fname, result);
		return 2;
	}
	else
	{
		Bsp_Printf("Delete The File Fail, The File Ready Only or the Directory isn't Empty (%d).\r\n", result);
		return 1;
	}
}

/**
  * @brief 读SD卡中的文件的数据
  * @param path,要读取的文件所在目录
  * @param fname,要读取的文件，必须是带绝对路径
  * @param ReadDataBuff,存储读取到的文件内部数据
  * @retval 0:正常;其他:退出
  */

uint8_t Bsp_FatFs_ReadFileData(const TCHAR* path, const TCHAR* fname, char* ReadDataBuff)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;
	FIL file;
	DIR DirInf;
	uint32_t bw;

	result = f_opendir(&DirInf, path);
	if (result != FR_OK)
	{
		Bsp_Printf("Open the directory %s failed (%d).\r\n", path, result);
		return 1;
	}
	result = f_open(&file, fname, FA_OPEN_EXISTING | FA_READ);
	if (result !=  FR_OK)
	{
		Bsp_Printf("The File %s is opened failed (%d).\r\n",fname, result);
		return 1;
	}
	result = f_read(&file, ReadDataBuff, strlen(WriteDataBuff), &bw);
	f_close(&file);
	if (bw > 0)
	{
		ReadDataBuff[bw] = 0;
		Bsp_Printf("The contents in the file %s are : \r\n%s\r\n", fname, ReadDataBuff);
		return 0;
	}
	else
	{
		Bsp_Printf("The file %s is empty. \r\n", fname);
		return 0;
	}

}

/**
  * @brief 写SD卡中的文件的数据
  * @param path,要写的文件所在目录
  * @param fname,要写的文件，必须是带绝对路径
  * @param WriteDataBuff,存储要写到文件内部的数据
  * @retval 0:正常;其他:退出
  */

uint8_t Bsp_FatFs_WriteFileData(const TCHAR* path, const TCHAR* fname, char* WriteDataBuff)
{
	/* 本函数使用的局部变量占用较多，请修改启动文件，保证堆栈空间够用 */
	FRESULT result;
	FIL file;
	DIR DirInf;
	uint32_t bw;

	result = f_opendir(&DirInf, path);
	if (result != FR_OK)
	{
		Bsp_Printf("Open the directory %s failed (%d).\r\n", path, result);
		return 1;
	}
	result = f_open(&file, fname, FA_CREATE_ALWAYS | FA_WRITE);
	if (result !=  FR_OK)
	{
		Bsp_Printf("The File %s is opened failed (%d).\r\n",fname, result);
		return 1;
	}	
	result = f_write(&file, WriteDataBuff, strlen(WriteDataBuff), &bw);
	f_close(&file);
	if (bw > 0)
	{
		Bsp_Printf("Write The Contents to the file %s sucess (%d).\r\n", fname, result);
		return 0;
	}
	else
	{
		Bsp_Printf("The file %s is empty. \r\n", fname);
		return 0;
	}

}

/** @}
*/
/****************************FasFt_User Exported Functions Group2*********************/
/** @}
*/
/*----------------------------------FasFt_User Exported Functions------------------------------------*/
/** @}
*/
/*----------------------------------------------FasFt_User-------------------------------------------*/
/** @}
*/
/*--------------------------------------STM32H743II_CoreBoard--------------------------------------*/
/*************************************************END OF FILE***************************************/
